/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GeminiTTSPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "",
  modelName: "gemini-2.5-flash-tts",
  voiceName: "Puck",
  stylePrompt: "Read clearly and naturally.",
  skipCodeBlocks: true
};
var GeminiTTSPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.currentAudio = null;
    this.isPlaying = false;
  }
  async onload() {
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.updateStatusBar("Ready");
    this.addRibbonIcon("microphone", "Read with Gemini TTS", (evt) => {
      this.triggerTTS();
    });
    this.addCommand({
      id: "gemini-tts-read-note",
      name: "Read active note",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (markdownView) {
          if (!checking) {
            this.triggerTTS();
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "gemini-tts-stop",
      name: "Stop playback",
      callback: () => {
        this.stopAudio();
      }
    });
    this.addSettingTab(new GeminiTTSSettingTab(this.app, this));
  }
  onunload() {
    this.stopAudio();
  }
  // --- Core Logic ---
  async triggerTTS() {
    if (this.isPlaying) {
      this.stopAudio();
      return;
    }
    const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    if (!activeView) {
      new import_obsidian.Notice("No active Markdown note found.");
      return;
    }
    const editor = activeView.editor;
    let textToRead = editor.getSelection();
    if (!textToRead) {
      textToRead = editor.getValue();
    }
    if (!textToRead.trim()) {
      new import_obsidian.Notice("Note is empty.");
      return;
    }
    const cleanedText = this.cleanText(textToRead);
    if (!cleanedText.trim()) {
      new import_obsidian.Notice("No readable text found after cleaning (e.g. only code blocks were present).");
      return;
    }
    this.updateStatusBar("Generating...");
    new import_obsidian.Notice("Gemini TTS: Generating audio...");
    try {
      const audioData = await this.fetchGeminiAudio(cleanedText);
      this.playAudio(audioData);
    } catch (error) {
      console.error("Gemini TTS Error:", error);
      new import_obsidian.Notice("TTS Error: Failed to generate audio. Check console for details.");
      this.updateStatusBar("Error");
    }
  }
  cleanText(text) {
    let clean = text;
    if (this.settings.skipCodeBlocks) {
      clean = clean.replace(/```[\s\S]*?```/g, "");
      clean = clean.replace(/`[^`]*`/g, "");
    }
    clean = clean.replace(/^---[\s\S]*?---/m, "");
    clean = clean.replace(/^#+\s+/gm, "");
    clean = clean.replace(/(\*\*|__)(.*?)\1/g, "$2");
    clean = clean.replace(/(\*|_)(.*?)\1/g, "$2");
    clean = clean.replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1");
    clean = clean.replace(/\[\[([^\]]+)\]\]/g, "$1");
    return clean;
  }
  async fetchGeminiAudio(text) {
    var _a;
    const apiKey = this.settings.apiKey;
    if (!apiKey)
      throw new Error("API Key is missing in settings.");
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.settings.modelName}:generateContent`;
    const payload = {
      contents: [{
        parts: [{
          text
        }]
      }],
      config: {
        responseModalities: ["AUDIO"],
        speechConfig: {
          voiceConfig: {
            prebuiltVoiceConfig: {
              voiceName: this.settings.voiceName
            }
          }
        }
      },
      systemInstruction: {
        parts: [
          { text: this.settings.stylePrompt }
        ]
      }
    };
    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-goog-api-key": apiKey
      },
      body: JSON.stringify(payload)
    });
    if (!response.ok) {
      const errText = await response.text();
      throw new Error(`API Request failed (${response.status}): ${errText}`);
    }
    const data = await response.json();
    const candidates = data.candidates;
    if (!candidates || candidates.length === 0)
      throw new Error("No content generated.");
    const parts = (_a = candidates[0].content) == null ? void 0 : _a.parts;
    if (!parts || parts.length === 0)
      throw new Error("No parts in response.");
    const inlineData = parts[0].inlineData;
    if (inlineData && inlineData.mimeType.startsWith("audio")) {
      const base64 = inlineData.data;
      const binaryString = window.atob(base64);
      const bytes = Uint8Array.from(binaryString, (char) => char.charCodeAt(0));
      return bytes.buffer;
    }
    throw new Error("No audio data found in response.");
  }
  playAudio(buffer) {
    const blob = new Blob([buffer], { type: "audio/*" });
    const url = window.URL.createObjectURL(blob);
    if (this.currentAudio) {
      this.currentAudio.pause();
    }
    this.currentAudio = new Audio(url);
    this.currentAudio.onplay = () => {
      this.isPlaying = true;
      this.updateStatusBar("Playing...");
    };
    this.currentAudio.onended = () => {
      this.isPlaying = false;
      this.updateStatusBar("Done");
      window.URL.revokeObjectURL(url);
    };
    this.currentAudio.onerror = (e) => {
      console.error("Audio playback error", e);
      this.isPlaying = false;
      this.updateStatusBar("Error");
      new import_obsidian.Notice("Error playing audio.");
      window.URL.revokeObjectURL(url);
    };
    this.currentAudio.play();
  }
  stopAudio() {
    if (this.currentAudio) {
      this.currentAudio.pause();
      if (this.currentAudio.src) {
        window.URL.revokeObjectURL(this.currentAudio.src);
      }
      this.currentAudio = null;
    }
    this.isPlaying = false;
    this.updateStatusBar("Stopped");
  }
  updateStatusBar(text) {
    this.statusBarItem.setText(`Gemini TTS: ${text}`);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var GeminiTTSSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Gemini TTS Settings" });
    new import_obsidian.Setting(containerEl).setName("API Key").setDesc("Your Google Gemini API Key").addText((text) => {
      text.setPlaceholder("Enter key...").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
      text.inputEl.autocomplete = "off";
    });
    new import_obsidian.Setting(containerEl).setName("Model Name").setDesc("Gemini Model ID (e.g., gemini-2.5-flash-tts)").addText((text) => text.setValue(this.plugin.settings.modelName).onChange(async (value) => {
      this.plugin.settings.modelName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Voice").setDesc("Select the voice persona.").addDropdown((drop) => drop.addOption("Puck", "Puck").addOption("Charon", "Charon").addOption("Kore", "Kore").addOption("Fenrir", "Fenrir").addOption("Aoede", "Aoede").setValue(this.plugin.settings.voiceName).onChange(async (value) => {
      this.plugin.settings.voiceName = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Style Prompt").setDesc('Instructions for the voice (e.g. "Read cheerfully").').addTextArea((text) => text.setValue(this.plugin.settings.stylePrompt).onChange(async (value) => {
      this.plugin.settings.stylePrompt = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Skip Code Blocks").setDesc("Remove content inside ``` blocks before reading.").addToggle((toggle) => toggle.setValue(this.plugin.settings.skipCodeBlocks).onChange(async (value) => {
      this.plugin.settings.skipCodeBlocks = value;
      await this.plugin.saveSettings();
    }));
  }
};
